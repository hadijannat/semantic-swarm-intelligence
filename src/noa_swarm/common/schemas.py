"""Core data schemas for the NOA Semantic Swarm Mapper.

This module defines the fundamental data structures used throughout the system:
- TagRecord: Discovered OPC UA tags
- Candidate: ML predictions for semantic mapping
- Hypothesis: Collection of candidates for a tag
- Vote: Agent votes in consensus process
- ConsensusRecord: Final agreed mappings
"""

from __future__ import annotations

from datetime import UTC, datetime
from typing import Annotated, Any, Literal

from pydantic import BaseModel, ConfigDict, Field, field_validator

from noa_swarm.common.ids import IRDI


def utc_now() -> datetime:
    """Return the current UTC datetime."""
    return datetime.now(UTC)


class TagRecord(BaseModel):
    """Represents a discovered tag from OPC UA server.

    TagRecords are created during the discovery phase when crawling
    OPC UA servers for available tags and their metadata.
    """

    model_config = ConfigDict(
        frozen=True,
        str_strip_whitespace=True,
        extra="forbid",
    )

    node_id: str = Field(
        ...,
        description="OPC UA node identifier (e.g., 'ns=2;s=Temperature.PV')",
        min_length=1,
    )
    browse_name: str = Field(
        ...,
        description="OPC UA browse name of the tag",
        min_length=1,
    )
    display_name: str | None = Field(
        default=None,
        description="Human-readable display name",
    )
    data_type: str | None = Field(
        default=None,
        description="OPC UA data type (e.g., 'Double', 'Boolean')",
    )
    description: str | None = Field(
        default=None,
        description="Tag description from OPC UA server",
    )
    parent_path: list[str] = Field(
        default_factory=list,
        description="Hierarchical path from root to parent node",
    )
    discovered_at: datetime = Field(
        default_factory=utc_now,
        description="Timestamp when tag was discovered",
    )
    source_server: str = Field(
        ...,
        description="OPC UA server endpoint URL",
        min_length=1,
    )
    engineering_unit: str | None = Field(
        default=None,
        description="Engineering unit if available (e.g., 'degC', 'bar')",
    )
    access_level: int | None = Field(
        default=None,
        description="OPC UA access level bitmask",
    )

    @property
    def full_path(self) -> str:
        """Return the full hierarchical path including the tag name."""
        if self.parent_path:
            return "/".join(self.parent_path) + "/" + self.browse_name
        return self.browse_name

    @property
    def tag_id(self) -> str:
        """Return a unique identifier for this tag.

        Combines server endpoint and node ID for uniqueness across servers.
        """
        return f"{self.source_server}|{self.node_id}"


class Candidate(BaseModel):
    """A single ML prediction for semantic mapping.

    Candidates are generated by ML models as potential semantic mappings
    for discovered tags. Each candidate includes an IRDI and confidence score.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="forbid",
    )

    irdi: str = Field(
        ...,
        description="IRDI of the predicted semantic concept",
        min_length=1,
    )
    confidence: Annotated[float, Field(ge=0.0, le=1.0)] = Field(
        ...,
        description="Prediction confidence score (0.0 to 1.0)",
    )
    source_model: str = Field(
        ...,
        description="Identifier of the ML model that generated this prediction",
        min_length=1,
    )
    features: dict[str, Any] | None = Field(
        default=None,
        description="Optional embedding vectors or feature data",
    )
    reasoning: str | None = Field(
        default=None,
        description="Optional explanation for the prediction",
    )

    @field_validator("irdi")
    @classmethod
    def validate_irdi(cls, v: str) -> str:
        """Validate and normalize the IRDI string."""
        if not IRDI.is_valid(v):
            raise ValueError(f"Invalid IRDI format: {v}")
        return IRDI.parse(v).to_canonical()

    @property
    def parsed_irdi(self) -> IRDI:
        """Return the parsed IRDI object."""
        return IRDI.parse(self.irdi)


class Hypothesis(BaseModel):
    """Collection of candidates for a single tag.

    A Hypothesis represents all ML predictions from a single agent
    for a given tag. Multiple hypotheses from different agents are
    combined during the consensus process.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="forbid",
    )

    tag_id: str = Field(
        ...,
        description="Unique identifier for the tag (server|node_id)",
        min_length=1,
    )
    candidates: list[Candidate] = Field(
        ...,
        description="List of candidate predictions, ordered by confidence",
        min_length=1,
    )
    created_at: datetime = Field(
        default_factory=utc_now,
        description="Timestamp when hypothesis was created",
    )
    agent_id: str = Field(
        ...,
        description="Identifier of the agent that generated this hypothesis",
        min_length=1,
    )
    model_version: str | None = Field(
        default=None,
        description="Version of the ML model used",
    )

    @field_validator("candidates")
    @classmethod
    def sort_candidates_by_confidence(cls, v: list[Candidate]) -> list[Candidate]:
        """Ensure candidates are sorted by confidence (highest first)."""
        return sorted(v, key=lambda c: c.confidence, reverse=True)

    @property
    def top_candidate(self) -> Candidate | None:
        """Return the highest confidence candidate."""
        return self.candidates[0] if self.candidates else None

    @property
    def top_irdi(self) -> str | None:
        """Return the IRDI of the highest confidence candidate."""
        return self.top_candidate.irdi if self.top_candidate else None


class Vote(BaseModel):
    """A single agent's vote in the consensus process.

    Votes are cast by agents during consensus and include confidence
    scores and reliability weighting.
    """

    model_config = ConfigDict(
        frozen=True,
        str_strip_whitespace=True,
        extra="forbid",
    )

    agent_id: str = Field(
        ...,
        description="Identifier of the voting agent",
        min_length=1,
    )
    candidate_irdi: str = Field(
        ...,
        description="IRDI being voted for",
        min_length=1,
    )
    confidence: Annotated[float, Field(ge=0.0, le=1.0)] = Field(
        ...,
        description="Agent's confidence in this vote",
    )
    reliability_score: Annotated[float, Field(ge=0.0, le=1.0)] = Field(
        ...,
        description="Agent's reliability score based on historical accuracy",
    )
    timestamp: datetime = Field(
        default_factory=utc_now,
        description="When the vote was cast",
    )

    @field_validator("candidate_irdi")
    @classmethod
    def validate_irdi(cls, v: str) -> str:
        """Validate and normalize the IRDI string."""
        if not IRDI.is_valid(v):
            raise ValueError(f"Invalid IRDI format: {v}")
        return IRDI.parse(v).to_canonical()

    @property
    def weighted_confidence(self) -> float:
        """Return confidence weighted by reliability score."""
        return self.confidence * self.reliability_score

    @property
    def parsed_irdi(self) -> IRDI:
        """Return the parsed IRDI object."""
        return IRDI.parse(self.candidate_irdi)


QuorumType = Literal["hard", "soft", "conflict"]


class ConsensusRecord(BaseModel):
    """Final agreed mapping from the consensus process.

    ConsensusRecords represent the outcome of swarm consensus on a tag mapping.
    They include the agreed IRDI, confidence metrics, and full audit trail.
    """

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="forbid",
    )

    tag_id: str = Field(
        ...,
        description="Unique identifier for the tag",
        min_length=1,
    )
    agreed_irdi: str = Field(
        ...,
        description="The IRDI agreed upon by consensus",
        min_length=1,
    )
    consensus_confidence: Annotated[float, Field(ge=0.0, le=1.0)] = Field(
        ...,
        description="Overall confidence in the consensus decision",
    )
    votes: list[Vote] = Field(
        ...,
        description="All votes cast during consensus",
        min_length=1,
    )
    quorum_type: QuorumType = Field(
        ...,
        description="Type of quorum achieved: hard, soft, or conflict",
    )
    human_validated: bool = Field(
        default=False,
        description="Whether a human has validated this mapping",
    )
    audit_trail: list[str] = Field(
        default_factory=list,
        description="Chronological log of consensus events",
    )
    created_at: datetime = Field(
        default_factory=utc_now,
        description="When consensus was reached",
    )
    updated_at: datetime = Field(
        default_factory=utc_now,
        description="Last update timestamp",
    )
    validation_notes: str | None = Field(
        default=None,
        description="Notes from human validation",
    )

    @field_validator("agreed_irdi")
    @classmethod
    def validate_irdi(cls, v: str) -> str:
        """Validate and normalize the IRDI string."""
        if not IRDI.is_valid(v):
            raise ValueError(f"Invalid IRDI format: {v}")
        return IRDI.parse(v).to_canonical()

    @property
    def parsed_irdi(self) -> IRDI:
        """Return the parsed IRDI object."""
        return IRDI.parse(self.agreed_irdi)

    @property
    def vote_count(self) -> int:
        """Return the number of votes."""
        return len(self.votes)

    @property
    def unique_voters(self) -> set[str]:
        """Return the set of unique voting agent IDs."""
        return {v.agent_id for v in self.votes}

    @property
    def is_unanimous(self) -> bool:
        """Check if all votes are for the agreed IRDI."""
        return all(v.candidate_irdi == self.agreed_irdi for v in self.votes)

    def add_audit_entry(self, entry: str) -> ConsensusRecord:
        """Create a new record with an added audit entry.

        Args:
            entry: The audit entry to add.

        Returns:
            New ConsensusRecord with the entry added.
        """
        return self.model_copy(
            update={
                "audit_trail": [*self.audit_trail, f"{utc_now().isoformat()}: {entry}"],
                "updated_at": utc_now(),
            }
        )

    def mark_validated(self, notes: str | None = None) -> ConsensusRecord:
        """Create a new record marked as human validated.

        Args:
            notes: Optional validation notes.

        Returns:
            New ConsensusRecord marked as validated.
        """
        return self.model_copy(
            update={
                "human_validated": True,
                "validation_notes": notes,
                "updated_at": utc_now(),
                "audit_trail": [
                    *self.audit_trail,
                    f"{utc_now().isoformat()}: Human validated"
                    + (f" - {notes}" if notes else ""),
                ],
            }
        )


# Type aliases for convenience
TagId = str
AgentId = str


MappingStatus = Literal["pending", "mapped", "verified", "rejected", "conflict"]


class TagMappingRecord(BaseModel):
    """Represents the current mapping state for a discovered tag."""

    model_config = ConfigDict(
        str_strip_whitespace=True,
        extra="forbid",
    )

    tag_id: str = Field(
        ...,
        description="Unique identifier for the tag (server|node_id)",
        min_length=1,
    )
    tag_name: str = Field(
        ...,
        description="Tag name or browse name",
        min_length=1,
    )
    browse_path: str = Field(
        ...,
        description="OPC UA browse path for the tag",
        min_length=1,
    )
    irdi: str | None = Field(
        default=None,
        description="Mapped IEC 61987 IRDI (if mapped)",
    )
    preferred_name: str | None = Field(
        default=None,
        description="Preferred dictionary name for the IRDI",
    )
    status: MappingStatus = Field(
        default="pending",
        description="Mapping status",
    )
    confidence: Annotated[float | None, Field(ge=0.0, le=1.0)] = Field(
        default=None,
        description="Confidence score for the mapping",
    )
    candidates: list[Candidate] = Field(
        default_factory=list,
        description="Candidate IRDIs proposed for this tag",
    )
    created_at: datetime = Field(
        default_factory=utc_now,
        description="Timestamp when mapping was created",
    )
    updated_at: datetime = Field(
        default_factory=utc_now,
        description="Timestamp when mapping was last updated",
    )

    @field_validator("irdi")
    @classmethod
    def validate_optional_irdi(cls, v: str | None) -> str | None:
        """Validate and normalize the IRDI string when provided."""
        if v is None:
            return v
        if not IRDI.is_valid(v):
            raise ValueError(f"Invalid IRDI format: {v}")
        return IRDI.parse(v).to_canonical()

    @property
    def is_mapped(self) -> bool:
        """Return True when the mapping is in a mapped or verified state."""
        return self.status in {"mapped", "verified"}
